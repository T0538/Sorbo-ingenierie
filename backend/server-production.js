const express = require('express');
const cors = require('cors');
const path = require('path');
const mongoose = require('mongoose');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
require('dotenv').config();

// Initialisation de l'application Express
const app = express();

// ===== S√âCURISATION =====

// Helmet pour la s√©curit√© des headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://unpkg.com"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limite chaque IP √† 100 requ√™tes par fen√™tre
  message: {
    success: false,
    message: 'Trop de requ√™tes depuis cette IP, veuillez r√©essayer plus tard.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

app.use(limiter);

// Configuration CORS s√©curis√©e
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      process.env.FRONTEND_URL,
      'https://sorbo-ingenierie.netlify.app',
      'https://sorbo-ingenierie.vercel.app',
      'http://localhost:3000',
      'http://localhost:5000'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Origine non autoris√©e par CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

// Middlewares de base avec limites
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Connexion MongoDB (optionnelle pour le serveur local)
let isMongoConnected = false;
if (process.env.MONGODB_URI) {
  mongoose.connect(process.env.MONGODB_URI)
    .then(() => {
      console.log('‚úÖ MongoDB connect√©');
      isMongoConnected = true;
    })
    .catch(err => {
      console.log('‚ö†Ô∏è MongoDB non connect√©, utilisation des donn√©es statiques');
    });
}

// Mod√®le Actualit√© pour MongoDB
const actualiteSchema = new mongoose.Schema({
  titre: { type: String, required: true },
  description: { type: String, required: true },
  contenu: { type: String, required: true },
  date: { type: Date, default: Date.now },
  auteur: { type: String, default: '√âquipe Sorbo Ing√©nierie' },
  image: { type: String },
  categorie: { type: String, default: 'Actualit√©' },
  tags: [{ type: String }]
});

const Actualite = mongoose.model('Actualite', actualiteSchema);

// Mod√®le Logiciel pour MongoDB
const logicielSchema = new mongoose.Schema({
  nom: { type: String, required: true },
  description: { type: String, required: true },
  categorie: { type: String, default: 'CAO' },
  version: { type: String, default: '2024' },
  prix: { type: String, default: 'Gratuit pour √©tudiants' },
  image: { type: String },
  downloadUrl: { type: String },
  trialUrl: { type: String },
  fonctionnalites: [{ type: String }],
  dateAjout: { type: Date, default: Date.now }
});

const Logiciel = mongoose.model('Logiciel', logicielSchema);

// Mod√®le Emploi pour MongoDB
const emploiSchema = new mongoose.Schema({
  poste: { type: String, required: true },
  description: { type: String, required: true },
  type: { type: String, default: 'CDI' },
  lieu: { type: String },
  salaire: { type: String },
  exigences: { type: String },
  dateAjout: { type: Date, default: Date.now }
});

const Emploi = mongoose.model('Emploi', emploiSchema);

// Route de sant√© simple
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    message: 'Serveur local Sorbo Ing√©nierie fonctionnel',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: 'local',
    mongoConnected: isMongoConnected
  });
});

// Route de test
app.get('/api/test', (req, res) => {
  res.json({
    success: true,
    message: 'API locale fonctionnelle !',
    data: {
      formations: 5,
      logiciels: 5,
      actualites: 5,
      contacts: 0,
      date: new Date().toISOString()
    }
  });
});

// Mod√®le Formation pour MongoDB
const formationSchema = new mongoose.Schema({
  titre: { type: String, required: true },
  description: { type: String, required: true },
  duree: { type: String },
  niveau: { type: String, default: 'D√©butant' },
  prix: { type: String },
  image: { type: String },
  categorie: { type: String, default: 'CAO' },
  dateAjout: { type: Date, default: Date.now }
});

const Formation = mongoose.model('Formation', formationSchema);

// Route formations avec MongoDB
app.get('/api/formations', async (req, res) => {
  try {
    let formations;
    
    if (isMongoConnected) {
      // R√©cup√©rer depuis MongoDB
      formations = await Formation.find().sort({ dateAjout: -1 });
      console.log(`üéì ${formations.length} formations r√©cup√©r√©es depuis MongoDB`);
    } else {
      // Aucune donn√©e si MongoDB non connect√©
      formations = [];
      console.log(`üéì Aucune formation disponible (MongoDB non connect√©)`);
    }

    res.json({
      success: true,
      message: 'Formations r√©cup√©r√©es avec succ√®s',
      data: formations,
      count: formations.length,
      source: isMongoConnected ? 'MongoDB' : 'Aucune donn√©e'
    });
  } catch (error) {
    console.error('Erreur formations:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des formations',
      error: error.message
    });
  }
});

// Route logiciels avec MongoDB
app.get('/api/logiciels', async (req, res) => {
  try {
    let logiciels;
    
    if (isMongoConnected) {
      // R√©cup√©rer depuis MongoDB
      logiciels = await Logiciel.find().sort({ dateAjout: -1 });
      console.log(`üíª ${logiciels.length} logiciels r√©cup√©r√©s depuis MongoDB`);
    } else {
      // Aucune donn√©e si MongoDB non connect√©
      logiciels = [];
      console.log(`üíª Aucun logiciel disponible (MongoDB non connect√©)`);
    }

    res.json({
      success: true,
      message: 'Logiciels r√©cup√©r√©s avec succ√®s',
      data: logiciels,
      count: logiciels.length,
      source: isMongoConnected ? 'MongoDB' : 'Aucune donn√©e'
    });
  } catch (error) {
    console.error('Erreur logiciels:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des logiciels',
      error: error.message
    });
  }
});

// Route pour ajouter un logiciel (admin)
app.post('/api/logiciels', async (req, res) => {
  try {
    const { nom, description, categorie, version, prix, image, downloadUrl, trialUrl, fonctionnalites } = req.body;
    
    // Validation
    if (!nom || !description) {
      return res.status(400).json({
        success: false,
        message: 'Nom et description sont requis'
      });
    }

    if (isMongoConnected) {
      // Sauvegarder dans MongoDB
      const nouveauLogiciel = new Logiciel({
        nom,
        description,
        categorie: categorie || 'CAO',
        version: version || '2024',
        prix: prix || 'Gratuit pour √©tudiants',
        image,
        downloadUrl,
        trialUrl,
        fonctionnalites: fonctionnalites || []
      });

      await nouveauLogiciel.save();
      console.log('üíª Nouveau logiciel ajout√© dans MongoDB:', nom);
      
      res.status(201).json({
        success: true,
        message: 'Logiciel ajout√© avec succ√®s',
        data: nouveauLogiciel
      });
    } else {
      // Simuler l'ajout si MongoDB non connect√©
      console.log('üíª Nouveau logiciel simul√©:', nom);
      
      res.status(201).json({
        success: true,
        message: 'Logiciel simul√© (MongoDB non connect√©)',
        data: {
          nom,
          description,
          categorie: categorie || 'CAO',
          version: version || '2024',
          prix: prix || 'Gratuit pour √©tudiants',
          dateAjout: new Date()
        }
      });
    }
  } catch (error) {
    console.error('Erreur ajout logiciel:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'ajout du logiciel',
      error: error.message
    });
  }
});

// Route t√©l√©chargement logiciel
app.get('/api/logiciels/:id/download', async (req, res) => {
  try {
    const logicielId = req.params.id;
    
    if (isMongoConnected) {
      // R√©cup√©rer depuis MongoDB
      const logiciel = await Logiciel.findById(logicielId);
      
      if (!logiciel) {
        return res.status(404).json({
          success: false,
          message: 'Logiciel non trouv√©'
        });
      }

      res.json({
        success: true,
        message: `Redirection vers ${logiciel.nom}`,
        data: {
          nom: logiciel.nom,
          downloadUrl: logiciel.downloadUrl,
          trialUrl: logiciel.trialUrl
        }
      });
    } else {
      return res.status(404).json({
        success: false,
        message: 'Aucun logiciel disponible (MongoDB non connect√©)'
      });
    }
  } catch (error) {
    console.error('Erreur t√©l√©chargement:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors du t√©l√©chargement',
      error: error.message
    });
  }
});

// Route actualit√©s avec MongoDB
app.get('/api/actualites', async (req, res) => {
  try {
    let actualites;
    
    if (isMongoConnected) {
      // R√©cup√©rer depuis MongoDB
      actualites = await Actualite.find().sort({ date: -1 }).limit(10);
      console.log(`üì∞ ${actualites.length} actualit√©s r√©cup√©r√©es depuis MongoDB`);
    } else {
      // Aucune donn√©e si MongoDB non connect√©
      actualites = [];
      console.log(`üì∞ Aucune actualit√© disponible (MongoDB non connect√©)`);
    }

    res.json({
      success: true,
      message: 'Actualit√©s r√©cup√©r√©es avec succ√®s',
      data: actualites,
      count: actualites.length,
      source: isMongoConnected ? 'MongoDB' : 'Aucune donn√©e'
    });
  } catch (error) {
    console.error('Erreur actualit√©s:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des actualit√©s',
      error: error.message
    });
  }
});

// Route pour ajouter une actualit√© (admin)
app.post('/api/actualites', async (req, res) => {
  try {
    const { titre, description, contenu, auteur, image, categorie, tags } = req.body;
    
    // Validation
    if (!titre || !description || !contenu) {
      return res.status(400).json({
        success: false,
        message: 'Titre, description et contenu sont requis'
      });
    }

    if (isMongoConnected) {
      // Sauvegarder dans MongoDB
      const nouvelleActualite = new Actualite({
        titre,
        description,
        contenu,
        auteur: auteur || '√âquipe Sorbo Ing√©nierie',
        image,
        categorie: categorie || 'Actualit√©',
        tags: tags || []
      });

      await nouvelleActualite.save();
      console.log('üì∞ Nouvelle actualit√© ajout√©e dans MongoDB:', titre);
      
      res.status(201).json({
        success: true,
        message: 'Actualit√© ajout√©e avec succ√®s',
        data: nouvelleActualite
      });
    } else {
      // Simuler l'ajout si MongoDB non connect√©
      console.log('üì∞ Nouvelle actualit√© simul√©e:', titre);
      
      res.status(201).json({
        success: true,
        message: 'Actualit√© simul√©e (MongoDB non connect√©)',
        data: {
          titre,
          description,
          contenu,
          date: new Date(),
          auteur: auteur || '√âquipe Sorbo Ing√©nierie'
        }
      });
    }
  } catch (error) {
    console.error('Erreur ajout actualit√©:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'ajout de l\'actualit√©',
      error: error.message
    });
  }
});

// Routes pour les emplois
app.get('/api/emplois', async (req, res) => {
  try {
    let emplois;
    
    if (isMongoConnected) {
      emplois = await Emploi.find().sort({ dateAjout: -1 });
      console.log(`üíº ${emplois.length} emplois r√©cup√©r√©s depuis MongoDB`);
    } else {
      emplois = [];
      console.log(`üíº Aucun emploi disponible (MongoDB non connect√©)`);
    }

    res.json({
      success: true,
      message: 'Emplois r√©cup√©r√©s avec succ√®s',
      data: emplois,
      count: emplois.length,
      source: isMongoConnected ? 'MongoDB' : 'Aucune donn√©e'
    });
  } catch (error) {
    console.error('Erreur emplois:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des emplois',
      error: error.message
    });
  }
});

app.post('/api/emplois', async (req, res) => {
  try {
    const { poste, description, type, lieu, salaire, exigences } = req.body;
    
    if (!poste || !description) {
      return res.status(400).json({
        success: false,
        message: 'Poste et description sont requis'
      });
    }

    if (isMongoConnected) {
      const nouvelEmploi = new Emploi({
        poste,
        description,
        type: type || 'CDI',
        lieu,
        salaire,
        exigences
      });

      await nouvelEmploi.save();
      console.log('üíº Nouvel emploi ajout√© dans MongoDB:', poste);
      
      res.status(201).json({
        success: true,
        message: 'Emploi ajout√© avec succ√®s',
        data: nouvelEmploi
      });
    } else {
      console.log('üíº Nouvel emploi simul√©:', poste);
      
      res.status(201).json({
        success: true,
        message: 'Emploi simul√© (MongoDB non connect√©)',
        data: {
          poste,
          description,
          type: type || 'CDI',
          dateAjout: new Date()
        }
      });
    }
  } catch (error) {
    console.error('Erreur ajout emploi:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'ajout de l\'emploi',
      error: error.message
    });
  }
});

// Routes CRUD pour les formations
app.post('/api/formations', async (req, res) => {
  try {
    const { titre, description, duree, niveau, prix, categorie, image } = req.body;
    
    if (!titre || !description) {
      return res.status(400).json({
        success: false,
        message: 'Titre et description sont requis'
      });
    }

    if (isMongoConnected) {
      // Sauvegarder dans MongoDB
      const nouvelleFormation = new Formation({
        titre,
        description,
        duree,
        niveau: niveau || 'D√©butant',
        prix,
        categorie: categorie || 'CAO',
        image
      });

      await nouvelleFormation.save();
      console.log('üéì Nouvelle formation ajout√©e dans MongoDB:', titre);
      
      res.status(201).json({
        success: true,
        message: 'Formation ajout√©e avec succ√®s',
        data: nouvelleFormation
      });
    } else {
      console.log('üéì Nouvelle formation simul√©e:', titre);
      
      res.status(201).json({
        success: true,
        message: 'Formation simul√©e (MongoDB non connect√©)',
        data: {
          titre,
          description,
          duree,
          niveau: niveau || 'D√©butant',
          prix,
          categorie: categorie || 'CAO',
          dateAjout: new Date()
        }
      });
    }
  } catch (error) {
    console.error('Erreur ajout formation:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'ajout de la formation',
      error: error.message
    });
  }
});

// Routes de suppression
app.delete('/api/actualites/:id', async (req, res) => {
  try {
    const id = req.params.id;
    
    if (isMongoConnected) {
      const result = await Actualite.findByIdAndDelete(id);
      if (result) {
        console.log('üì∞ Actualit√© supprim√©e:', id);
        res.json({ success: true, message: 'Actualit√© supprim√©e avec succ√®s' });
      } else {
        res.status(404).json({ success: false, message: 'Actualit√© non trouv√©e' });
      }
    } else {
      console.log('üì∞ Suppression simul√©e:', id);
      res.json({ success: true, message: 'Suppression simul√©e' });
    }
  } catch (error) {
    console.error('Erreur suppression actualit√©:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression',
      error: error.message
    });
  }
});

app.delete('/api/logiciels/:id', async (req, res) => {
  try {
    const id = req.params.id;
    
    if (isMongoConnected) {
      const result = await Logiciel.findByIdAndDelete(id);
      if (result) {
        console.log('üíª Logiciel supprim√©:', id);
        res.json({ success: true, message: 'Logiciel supprim√© avec succ√®s' });
      } else {
        res.status(404).json({ success: false, message: 'Logiciel non trouv√©' });
      }
    } else {
      console.log('üíª Suppression simul√©e:', id);
      res.json({ success: true, message: 'Suppression simul√©e' });
    }
  } catch (error) {
    console.error('Erreur suppression logiciel:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression',
      error: error.message
    });
  }
});

app.delete('/api/emplois/:id', async (req, res) => {
  try {
    const id = req.params.id;
    
    if (isMongoConnected) {
      const result = await Emploi.findByIdAndDelete(id);
      if (result) {
        console.log('üíº Emploi supprim√©:', id);
        res.json({ success: true, message: 'Emploi supprim√© avec succ√®s' });
      } else {
        res.status(404).json({ success: false, message: 'Emploi non trouv√©' });
      }
    } else {
      console.log('üíº Suppression simul√©e:', id);
      res.json({ success: true, message: 'Suppression simul√©e' });
    }
  } catch (error) {
    console.error('Erreur suppression emploi:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression',
      error: error.message
    });
  }
});

// Route de suppression pour les formations
app.delete('/api/formations/:id', async (req, res) => {
  try {
    const id = req.params.id;
    
    if (isMongoConnected) {
      const result = await Formation.findByIdAndDelete(id);
      if (result) {
        console.log('üéì Formation supprim√©e:', id);
        res.json({ success: true, message: 'Formation supprim√©e avec succ√®s' });
      } else {
        res.status(404).json({ success: false, message: 'Formation non trouv√©e' });
      }
    } else {
      console.log('üéì Suppression simul√©e:', id);
      res.json({ success: true, message: 'Suppression simul√©e' });
    }
  } catch (error) {
    console.error('Erreur suppression formation:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression',
      error: error.message
    });
  }
});

// Route contact simple
app.post('/api/contact', (req, res) => {
  try {
    const { name, email, phone, subject, message } = req.body;
    
    // Validation simple
    if (!name || !email || !message) {
      return res.status(400).json({
        success: false,
        message: 'Nom, email et message sont requis'
      });
    }
    
    // Simuler l'enregistrement
    console.log('üìû Nouveau contact re√ßu:', { name, email, phone, subject, message });
    
    res.status(200).json({
      success: true,
      message: 'Contact re√ßu avec succ√®s',
      data: {
        id: Date.now(),
        name,
        email,
        phone,
        subject,
        message,
        createdAt: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Erreur contact:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'envoi du contact',
      error: error.message
    });
  }
});

// Servir les fichiers statiques
app.use(express.static(path.join(__dirname, '../')));

// Middleware de gestion des erreurs simple
app.use((err, req, res, next) => {
  console.error('Erreur:', err.message);
  res.status(500).json({
    success: false,
    message: 'Erreur serveur',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Erreur interne'
  });
});

// Port et d√©marrage du serveur
const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`üöÄ Serveur de production d√©marr√© sur le port ${PORT}`);
  console.log(`üìä Mode: ${process.env.NODE_ENV || 'production'}`);
  console.log(`üîó URL: http://localhost:${PORT}`);
  console.log(`‚úÖ API Health: http://localhost:${PORT}/api/health`);
  console.log(`üìû Contact: http://localhost:${PORT}/api/contact`);
  console.log(`üéì Formations: http://localhost:${PORT}/api/formations`);
  console.log(`üíª Logiciels: http://localhost:${PORT}/api/logiciels`);
  console.log(`üì∞ Actualit√©s: http://localhost:${PORT}/api/actualites`);
  console.log(`üì• T√©l√©chargements: http://localhost:${PORT}/api/logiciels/:id/download`);
  console.log(`üíº Emplois: http://localhost:${PORT}/api/emplois`);
  console.log(`üåê Frontend: http://localhost:${PORT}`);
  console.log(`üéõÔ∏è Admin: http://localhost:${PORT}/admin-dashboard.html`);
  console.log(`üîí S√©curit√©: Rate limiting, Helmet, CORS configur√©`);
}); 